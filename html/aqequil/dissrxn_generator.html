<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>aqequil.dissrxn_generator API documentation</title>
<meta name="description" content="Module for generating dissociation reactions for species that lack them â€¦">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>aqequil.dissrxn_generator</code></h1>
</header>
<section id="section-intro">
<p>Module for generating dissociation reactions for species that lack them.</p>
<p>This module uses CHNOSZ to automatically generate balanced dissociation reactions
using strict and auxiliary basis species.</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="aqequil.dissrxn_generator.coefficients_to_integers"><code class="name flex">
<span>def <span class="ident">coefficients_to_integers</span></span>(<span>coeffs, tolerance=1e-06)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def coefficients_to_integers(coeffs, tolerance=1e-6):
    &#34;&#34;&#34;
    Convert fractional coefficients to integers by finding LCM of denominators.

    Parameters
    ----------
    coeffs : list
        List of coefficient values (can be floats)
    tolerance : float
        Tolerance for considering a coefficient as zero

    Returns
    -------
    list
        List of integer coefficients
    &#34;&#34;&#34;
    # Convert to fractions and find LCM of denominators
    fractions = []
    for c in coeffs:
        if abs(c) &lt; tolerance:
            fractions.append(Fraction(0))
        else:
            frac = Fraction(c).limit_denominator(10000)
            fractions.append(frac)

    # Get LCM of all denominators
    denominators = [f.denominator for f in fractions]
    lcm_val = get_lcm_list(denominators) if denominators else 1

    # Multiply all coefficients by LCM
    integer_coeffs = [float(f.numerator * lcm_val // f.denominator) for f in fractions]

    return integer_coeffs</code></pre>
</details>
<div class="desc"><p>Convert fractional coefficients to integers by finding LCM of denominators.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coeffs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of coefficient values (can be floats)</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>Tolerance for considering a coefficient as zero</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of integer coefficients</dd>
</dl></div>
</dd>
<dt id="aqequil.dissrxn_generator.find_species_needing_dissrxns"><code class="name flex">
<span>def <span class="ident">find_species_needing_dissrxns</span></span>(<span>thermo_df, verbose=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_species_needing_dissrxns(thermo_df, verbose=1):
    &#34;&#34;&#34;
    Find all species that need dissociation reactions (missing or unbalanced).

    Parameters
    ----------
    thermo_df : pd.DataFrame
        Thermodynamic database dataframe
    verbose : int
        Verbosity level

    Returns
    -------
    list
        List of species names that need dissociation reactions
    &#34;&#34;&#34;
    from .dissrxn_balancer import check_dissrxn_balanced

    needs_dissrxn = []

    for idx, row in thermo_df.iterrows():
        # Skip basis species
        if row.get(&#39;tag&#39;) == &#39;basis&#39;:
            continue

        sp_name = row[&#39;name&#39;]
        dissrxn = row.get(&#39;dissrxn&#39;, &#39;&#39;)

        # Check if dissociation reaction is missing or unbalanced
        # Handle both string and NaN/None cases
        if pd.isna(dissrxn) or dissrxn == &#39;&#39; or (isinstance(dissrxn, str) and dissrxn.strip() == &#39;&#39;):
            needs_dissrxn.append(sp_name)
        elif not check_dissrxn_balanced(str(dissrxn), sp_name, verbose=verbose &gt;= 2):
            needs_dissrxn.append(sp_name)

    return needs_dissrxn</code></pre>
</details>
<div class="desc"><p>Find all species that need dissociation reactions (missing or unbalanced).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>thermo_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Thermodynamic database dataframe</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Verbosity level</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of species names that need dissociation reactions</dd>
</dl></div>
</dd>
<dt id="aqequil.dissrxn_generator.gcd"><code class="name flex">
<span>def <span class="ident">gcd</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gcd(a, b):
    &#34;&#34;&#34;Greatest common divisor.&#34;&#34;&#34;
    while b:
        a, b = b, a % b
    return abs(a)</code></pre>
</details>
<div class="desc"><p>Greatest common divisor.</p></div>
</dd>
<dt id="aqequil.dissrxn_generator.generate_dissrxn"><code class="name flex">
<span>def <span class="ident">generate_dissrxn</span></span>(<span>sp_name,<br>thermo_df,<br>basis_pref,<br>aux_pref=None,<br>HOZ_balancers=None,<br>verbose=1,<br>redox_elem_states=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_dissrxn(sp_name, thermo_df, basis_pref, aux_pref=None,
                     HOZ_balancers=None, verbose=1, redox_elem_states=None):
    &#34;&#34;&#34;
    Generate a dissociation reaction for a species.

    This function replicates the logic from the R function spec_diss() in
    redox_and_dissrxns.r (lines 536-775), which uses oxidation state information
    to choose the most appropriate basis species.

    Parameters
    ----------
    sp_name : str
        Name of species to generate dissociation reaction for
    thermo_df : pd.DataFrame
        Thermodynamic database dataframe with formula, formula_ox, tag columns
    basis_pref : dict
        Dictionary mapping elements (including pseudoelements) to preferred basis species names
    aux_pref : dict, optional
        Dictionary mapping elements to lists of preferred auxiliary basis species
    HOZ_balancers : list, optional
        List of species to use for balancing H, O, and charge
    verbose : int
        Verbosity level
    redox_elem_states : dict, optional
        Dictionary mapping elements to their pseudoelement names for each oxidation state
        Format: {element: {ox_state_string: pseudoelement_name}}

    Returns
    -------
    str
        Dissociation reaction string, or None if generation fails
    &#34;&#34;&#34;
    if HOZ_balancers is None:
        HOZ_balancers = [&#34;H+&#34;, &#34;O2(g)&#34;, &#34;H2O&#34;]

    if aux_pref is None:
        aux_pref = {}

    if redox_elem_states is None:
        redox_elem_states = {}

    try:
        # Get formula for this species
        sp_row = thermo_df[thermo_df[&#39;name&#39;] == sp_name]
        if sp_row.empty:
            return None

        # Use formula_modded if available (for redox-suppressed elements), else use formula
        sp_formula = sp_row.iloc[0].get(&#39;formula_modded&#39;, sp_row.iloc[0][&#39;formula&#39;])
        # If formula_modded is NaN or empty, fall back to formula
        if pd.isna(sp_formula) or sp_formula == &#39;&#39; or sp_formula == &#39;nan&#39;:
            sp_formula = sp_row.iloc[0][&#39;formula&#39;]

        # Get formula_ox_modded for oxidation state information
        sp_formula_ox_modded = sp_row.iloc[0].get(&#39;formula_ox_modded&#39;, &#39;nan&#39;)
        if pd.isna(sp_formula_ox_modded) or sp_formula_ox_modded == &#39;nan&#39; or sp_formula_ox_modded == &#39;&#39;:
            sp_formula_ox_modded = sp_row.iloc[0].get(&#39;formula_ox&#39;, &#39;nan&#39;)

        # Get elemental composition
        comp = pychnosz.makeup(sp_formula)

        # Get elements that are not H, O, Z (including pseudoelements)
        basis_elem = [e for e in comp.keys() if e not in [&#39;H&#39;, &#39;O&#39;, &#39;Z&#39;]]

        # Special case: if this is a gas species and there&#39;s an aqueous species with the same formula_modded
        # that is a basis species, create a simple phase-change reaction
        # e.g., CH4(g) -&gt; CH4(aq), CO(g) -&gt; CO(aq), S2(g) -&gt; S2(aq)
        if sp_row.iloc[0].get(&#39;state&#39;) == &#39;gas&#39;:
            # Look for an aqueous basis species with matching formula_modded
            matching_aq_basis = thermo_df[
                (thermo_df[&#39;tag&#39;] == &#39;basis&#39;) &amp;
                (thermo_df[&#39;state&#39;] == &#39;aq&#39;) &amp;
                (thermo_df[&#39;formula_modded&#39;] == sp_formula)
            ]
            if not matching_aq_basis.empty:
                aq_species_name = matching_aq_basis.iloc[0][&#39;name&#39;]
                # Simple phase change reaction
                dissrxn_str = f&#34;-1.0000 {sp_name} 1.0000 {aq_species_name}&#34;
                if verbose &gt;= 2:
                    print(f&#34;  Phase change reaction: {dissrxn_str}&#34;)
                return dissrxn_str

        # Determine which basis species to use for each element
        # This implements the oxidation-state-aware selection logic from R&#39;s spec_diss()
        chosen_basis_species = []
        chosen_basis_coeffs = []

        # If we don&#39;t have oxidation state information, use simple method
        if pd.isna(sp_formula_ox_modded) or sp_formula_ox_modded == &#39;nan&#39; or sp_formula_ox_modded == &#39;&#39;:
            # Simple method: just use basis_pref
            for elem in basis_elem:
                if elem in basis_pref:
                    chosen_basis_species.append(basis_pref[elem])
                    chosen_basis_coeffs.append(comp[elem])
        else:
            # Oxidation-state-aware method (R code lines 583-706)
            # For each element, match oxidation states to basis/aux species

            for elem in basis_elem:
                # Get count of this element in the species
                elem_count = comp[elem]

                # Check if this is a pseudoelement (redox-suppressed element)
                # Pseudoelements have names like &#34;Fejiiip&#34;, &#34;Sjin&#34;, &#34;Cjivn&#34;
                is_pseudoelement = &#39;j&#39; in elem and any(c in elem for c in [&#39;i&#39;, &#39;v&#39;, &#39;x&#39;, &#39;p&#39;, &#39;n&#39;, &#39;z&#39;])

                if is_pseudoelement:
                    # This is a pseudoelement from redox suppression
                    # Use the preferred basis species directly
                    if elem in basis_pref:
                        chosen_basis_species.append(basis_pref[elem])
                        chosen_basis_coeffs.append(elem_count)
                    continue

                # Element is NOT redox-suppressed
                # Use oxidation-state matching to find best basis/aux species
                # This replicates R code lines 605-706

                # Check if we have aux_pref for this element
                if elem not in aux_pref or not aux_pref[elem]:
                    # No aux preference - just use simplest basis
                    if elem in basis_pref:
                        chosen_basis_species.append(basis_pref[elem])
                        chosen_basis_coeffs.append(elem_count)
                    continue

                # Get oxidation states of this element in the species
                elem_ox_states = get_element_oxidation_states(sp_formula_ox_modded, elem)

                if not elem_ox_states:
                    # Couldn&#39;t parse oxidation states, fall back to simple method
                    if elem in basis_pref:
                        chosen_basis_species.append(basis_pref[elem])
                        chosen_basis_coeffs.append(elem_count)
                    continue

                # Get available basis and aux species for this element
                # Build a list of (species_name, average_ox_state, formula_ox)
                basis_aux_candidates = []

                # Get the strict basis species for this element
                if elem in basis_pref:
                    basis_sp_name = basis_pref[elem]
                    basis_row = thermo_df[thermo_df[&#39;name&#39;] == basis_sp_name]
                    if not basis_row.empty:
                        basis_formula_ox = basis_row.iloc[0].get(&#39;formula_ox_modded&#39;,
                                                                   basis_row.iloc[0].get(&#39;formula_ox&#39;, &#39;&#39;))
                        avg_ox = get_average_oxidation_state(basis_formula_ox, elem)
                        basis_aux_candidates.append((basis_sp_name, avg_ox, basis_formula_ox))

                # Get aux species for this element
                for aux_sp_name in aux_pref[elem]:
                    # Don&#39;t allow a species to dissociate into itself
                    if aux_sp_name == sp_name:
                        continue
                    aux_row = thermo_df[thermo_df[&#39;name&#39;] == aux_sp_name]
                    if not aux_row.empty:
                        aux_formula_ox = aux_row.iloc[0].get(&#39;formula_ox_modded&#39;,
                                                               aux_row.iloc[0].get(&#39;formula_ox&#39;, &#39;&#39;))
                        avg_ox = get_average_oxidation_state(aux_formula_ox, elem)
                        basis_aux_candidates.append((aux_sp_name, avg_ox, aux_formula_ox))

                if not basis_aux_candidates:
                    # No candidates found, fall back
                    if elem in basis_pref:
                        chosen_basis_species.append(basis_pref[elem])
                        chosen_basis_coeffs.append(elem_count)
                    continue

                # For each oxidation state instance in the species, find the closest matching basis/aux
                # This implements R code lines 651-705
                if len(elem_ox_states) == 1:
                    # Simple case: element has one oxidation state
                    ox_state, count = elem_ox_states[0]

                    # Find closest matching basis/aux species
                    closest_sp = min(basis_aux_candidates, key=lambda x: abs(x[1] - ox_state))
                    chosen_sp_name = closest_sp[0]

                    # Get how many atoms of this element are in the chosen basis species
                    chosen_row = thermo_df[thermo_df[&#39;name&#39;] == chosen_sp_name]
                    chosen_formula = chosen_row.iloc[0].get(&#39;formula_modded&#39;, chosen_row.iloc[0][&#39;formula&#39;])
                    if pd.isna(chosen_formula) or chosen_formula == &#39;&#39; or chosen_formula == &#39;nan&#39;:
                        chosen_formula = chosen_row.iloc[0][&#39;formula&#39;]
                    chosen_makeup = pychnosz.makeup(chosen_formula)
                    n_elem_in_chosen = chosen_makeup.get(elem, 1)

                    # Coefficient = (count of elem in species) / (count of elem in basis)
                    coeff = count / n_elem_in_chosen

                    chosen_basis_species.append(chosen_sp_name)
                    chosen_basis_coeffs.append(coeff)
                else:
                    # Complex case: element has multiple oxidation states
                    # e.g., linnaeite has Co+2 and Co+3
                    # Match each oxidation state to the closest basis/aux species
                    chosen_dict = {}  # species_name -&gt; coefficient

                    for ox_state, count in elem_ox_states:
                        # Find closest matching basis/aux species for this oxidation state
                        closest_sp = min(basis_aux_candidates, key=lambda x: abs(x[1] - ox_state))
                        chosen_sp_name = closest_sp[0]

                        # Get how many atoms of this element are in the chosen basis species
                        chosen_row = thermo_df[thermo_df[&#39;name&#39;] == chosen_sp_name]
                        chosen_formula = chosen_row.iloc[0].get(&#39;formula_modded&#39;, chosen_row.iloc[0][&#39;formula&#39;])
                        if pd.isna(chosen_formula) or chosen_formula == &#39;&#39; or chosen_formula == &#39;nan&#39;:
                            chosen_formula = chosen_row.iloc[0][&#39;formula&#39;]
                        chosen_makeup = pychnosz.makeup(chosen_formula)
                        n_elem_in_chosen = chosen_makeup.get(elem, 1)

                        # Coefficient for this instance
                        coeff = count / n_elem_in_chosen

                        # Accumulate coefficients for the same species
                        if chosen_sp_name in chosen_dict:
                            chosen_dict[chosen_sp_name] += coeff
                        else:
                            chosen_dict[chosen_sp_name] = coeff

                    # Add all chosen species and coefficients
                    for sp_name_inner, coeff in chosen_dict.items():
                        chosen_basis_species.append(sp_name_inner)
                        chosen_basis_coeffs.append(coeff)

        # New approach: use formula_ox_modded to directly identify which basis/aux species to use
        # This replicates the workflow that successfully works in testing

        # Build basis_to_elem mapping (basis species -&gt; element/pseudoelement)
        basis_to_elem = {}
        for idx, row in thermo_df[thermo_df[&#39;tag&#39;] == &#39;basis&#39;].iterrows():
            try:
                formula_modded = row.get(&#39;formula_modded&#39;, row[&#39;formula&#39;])
                if pd.isna(formula_modded) or formula_modded == &#39;&#39;:
                    continue
                mkp = pychnosz.makeup(str(formula_modded))
                elems = [e for e in mkp.keys() if e not in [&#39;H&#39;, &#39;O&#39;, &#39;Z&#39;]]
                if len(elems) == 1:
                    basis_to_elem[row[&#39;name&#39;]] = elems[0]
            except:
                continue

        # Reverse mapping: element/pseudoelement -&gt; basis species
        elem_to_basis = {v: k for k, v in basis_to_elem.items()}

        # Parse formula_ox_modded to get element+oxidation combinations
        # Use shared function that handles pseudoelements
        element_ox_modded = parse_formula_ox_string(sp_formula_ox_modded, include_pseudoelements=True)

        # For each element+oxidation in formula_ox_modded, find the appropriate basis/aux species
        basis_to_add = []
        for el_with_charge in element_ox_modded.keys():
            # Extract just the element/pseudoelement part (remove charge and digits)
            el = el_with_charge.rstrip(&#39;0123456789+-&#39;)

            # Extract oxidation state from el_with_charge (e.g., &#34;Cu+1&#34; -&gt; 1, &#34;S-2&#34; -&gt; -2)
            ox_state_str = el_with_charge[len(el):]  # e.g., &#34;+1&#34;, &#34;-2&#34;
            try:
                ox_state_val = int(ox_state_str) if ox_state_str else 0
            except:
                ox_state_val = 0

            # Try to find basis/aux species with matching oxidation state
            # Format: Convert &#34;Cu+1&#34; to &#34;Cu+&#34; or &#34;Cu+2&#34; to &#34;Cu+2&#34; (standard ionic notation)
            if ox_state_val != 0:
                # Generate possible ionic notation forms
                # For +1, try &#34;Cu+&#34; and &#34;Cu+1&#34;
                # For +2, try &#34;Cu+2&#34; and &#34;Cu++&#34;
                # For -2, try &#34;S-2&#34; and &#34;S--&#34;
                possible_names = []
                if ox_state_val &gt; 0:
                    # Positive charge
                    possible_names.append(f&#34;{el}+{abs(ox_state_val)}&#34; if abs(ox_state_val) &gt; 1 else f&#34;{el}+&#34;)
                    possible_names.append(f&#34;{el}{&#39;+&#39;*abs(ox_state_val)}&#34;)
                else:
                    # Negative charge
                    possible_names.append(f&#34;{el}-{abs(ox_state_val)}&#34; if abs(ox_state_val) &gt; 1 else f&#34;{el}-&#34;)
                    possible_names.append(f&#34;{el}{&#39;-&#39;*abs(ox_state_val)}&#34;)

                # Check if any of these forms exist as basis/aux species
                found = False
                for possible_name in possible_names:
                    if possible_name in list(thermo_df[&#39;name&#39;]):
                        el_db_entry = thermo_df[thermo_df[&#39;name&#39;] == possible_name].iloc[0]
                        if el_db_entry[&#39;tag&#39;] in [&#39;basis&#39;, &#39;aux&#39;, &#39;refstate&#39;]:
                            basis_to_add.append(possible_name)
                            if verbose &gt;= 2:
                                print(f&#34;  Found {possible_name} for {el_with_charge} (tag={el_db_entry[&#39;tag&#39;]})&#34;)
                            found = True
                            break

                if found:
                    continue

            # Check if el is a pseudoelement and map to basis
            if el in elem_to_basis:
                basis_sp = elem_to_basis[el]
                basis_to_add.append(basis_sp)
                if verbose &gt;= 2:
                    print(f&#34;  Mapped {el} -&gt; {basis_sp}&#34;)
                continue

        # Remove duplicates while preserving order
        seen = set()
        basis_to_add = [x for x in basis_to_add if not (x in seen or seen.add(x))]

        if verbose &gt;= 2:
            print(f&#34;  Basis species to add: {basis_to_add}&#34;)

        # Try with just H+ first (works for linnaeite)
        # If that fails, try with partial HOZ [H+, H2O] (needed for ilvaite)
        # If that fails, try with full HOZ_balancers (needed for laurite)
        hoz_for_basis = [hb.replace(&#39;(g)&#39;, &#39;&#39;) if hb == &#39;O2(g)&#39; else hb for hb in HOZ_balancers]

        try:
            # Try with just H+
            basis_list = basis_to_add + [&#39;H+&#39;]
            seen = set()
            basis_list = [x for x in basis_list if not (x in seen or seen.add(x))]

            if verbose &gt;= 2:
                print(f&#34;  Trying basis with H+: {basis_list}&#34;)

            b = pychnosz.basis(basis_list, messages=False, global_state=False)

            # Use balance_reaction instead of subcrt for efficiency
            # This only calculates the stoichiometry without thermodynamic properties
            balance_result = pychnosz.balance_reaction([sp_name], [-1], basis=b, messages=False)

            if balance_result is None:
                raise Exception(&#34;balance_reaction returned None&#34;)

            balanced_species, coeffs = balance_result

        except Exception as e:
            # Try with partial HOZ (H+ and H2O only)
            if verbose &gt;= 2:
                print(f&#34;  H+ only failed ({e}), trying partial HOZ [H+, H2O]&#34;)

            try:
                basis_list = basis_to_add + [&#39;H+&#39;, &#39;H2O&#39;]
                seen = set()
                basis_list = [x for x in basis_list if not (x in seen or seen.add(x))]

                if verbose &gt;= 2:
                    print(f&#34;  Trying basis with H+ and H2O: {basis_list}&#34;)

                b = pychnosz.basis(basis_list, messages=False, global_state=False)

                # Use balance_reaction instead of subcrt for efficiency
                balance_result = pychnosz.balance_reaction([sp_name], [-1], basis=b, messages=False)

                if balance_result is None:
                    raise Exception(&#34;balance_reaction returned None&#34;)

                balanced_species, coeffs = balance_result

            except Exception as e2:
                # Try with full HOZ_balancers
                if verbose &gt;= 2:
                    print(f&#34;  Partial HOZ failed ({e2}), trying full HOZ&#34;)

                basis_list = basis_to_add + hoz_for_basis
                seen = set()
                basis_list = [x for x in basis_list if not (x in seen or seen.add(x))]

                if verbose &gt;= 2:
                    print(f&#34;  Trying basis with full HOZ: {basis_list}&#34;)

                try:
                    b = pychnosz.basis(basis_list, messages=False, global_state=False)

                    # Use balance_reaction instead of subcrt for efficiency
                    balance_result = pychnosz.balance_reaction([sp_name], [-1], basis=b, messages=False)

                    if balance_result is None:
                        return None

                    balanced_species, coeffs = balance_result

                except Exception as e3:
                    if verbose &gt;= 2:
                        print(f&#34;  Error: {e3}&#34;)
                    return None

        # Convert species to names if they are indices
        # CRITICAL: indices from balance_reaction() are 1-based CHNOSZ OBIGT indices
        # These must be looked up using .loc[] not .iloc[]
        species_names = []
        thermo_sys = pychnosz.thermo()
        for sp in balanced_species:
            if isinstance(sp, (int, np.int64, np.int32)):
                # Species index from CHNOSZ - use .loc[] to look up (1-based label)
                if sp in thermo_sys.obigt.index:
                    species_names.append(thermo_sys.obigt.loc[sp][&#39;name&#39;])
                else:
                    # Fallback: species might not be in CHNOSZ but in thermo_df
                    sp_name_lookup = thermo_df[thermo_df[&#39;name&#39;].notna()].query(f&#39;name == &#34;{sp}&#34;&#39;)
                    if len(sp_name_lookup) &gt; 0:
                        species_names.append(sp_name_lookup.iloc[0][&#39;name&#39;])
                    else:
                        species_names.append(str(sp))
            else:
                species_names.append(sp)

        # Filter out polymorphs of the dissociating species
        filtered_coeffs = []
        filtered_names = []
        found_primary = False
        for coeff, name in zip(coeffs, species_names):
            if name == sp_name:
                if not found_primary and coeff &lt; 0:
                    filtered_coeffs.append(coeff)
                    filtered_names.append(name)
                    found_primary = True
            else:
                filtered_coeffs.append(coeff)
                filtered_names.append(name)

        coeffs = filtered_coeffs
        species_names = filtered_names

        # Replace &#39;water&#39; with &#39;H2O&#39; for EQ3 compatibility
        species_names = [&#39;H2O&#39; if n == &#39;water&#39; else n for n in species_names]

        # Restore (g) suffix for gas species that were in HOZ_balancers
        # e.g., convert &#39;O2&#39; back to &#39;O2(g)&#39; if &#39;O2(g)&#39; was in HOZ_balancers
        for i, name in enumerate(species_names):
            for hb in HOZ_balancers:
                if &#39;(g)&#39; in hb:
                    # Extract base name without (g) suffix
                    base_name = hb.replace(&#39;(g)&#39;, &#39;&#39;)
                    if name == base_name:
                        species_names[i] = hb
                        break

        # Convert coefficients to integers if needed (R code lines 728-761)
        if any(abs(c % 1) &gt; 1e-6 for c in coeffs):
            coeffs = coefficients_to_integers(coeffs)

        # Reduce coefficients to their simplest form by dividing by their GCD
        coeffs = reduce_coefficients(coeffs)

        # Format as string
        parts = []
        for coeff, name in zip(coeffs, species_names):
            parts.append(f&#34;{coeff:.4f}&#34;)
            parts.append(name)

        dissrxn_str = &#34; &#34;.join(parts)

        if verbose &gt;= 2:
            print(f&#34;Generated dissociation reaction for {sp_name}:&#34;)
            print(f&#34;  {dissrxn_str}&#34;)

        return dissrxn_str

    except Exception as e:
        if verbose &gt;= 1:
            print(f&#34;Error generating dissociation reaction for {sp_name}: {e}&#34;)
        import traceback
        if verbose &gt;= 2:
            traceback.print_exc()
        return None</code></pre>
</details>
<div class="desc"><p>Generate a dissociation reaction for a species.</p>
<p>This function replicates the logic from the R function spec_diss() in
redox_and_dissrxns.r (lines 536-775), which uses oxidation state information
to choose the most appropriate basis species.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sp_name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of species to generate dissociation reaction for</dd>
<dt><strong><code>thermo_df</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>Thermodynamic database dataframe with formula, formula_ox, tag columns</dd>
<dt><strong><code>basis_pref</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dictionary mapping elements (including pseudoelements) to preferred basis species names</dd>
<dt><strong><code>aux_pref</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary mapping elements to lists of preferred auxiliary basis species</dd>
<dt><strong><code>HOZ_balancers</code></strong> :&ensp;<code>list</code>, optional</dt>
<dd>List of species to use for balancing H, O, and charge</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>int</code></dt>
<dd>Verbosity level</dd>
<dt><strong><code>redox_elem_states</code></strong> :&ensp;<code>dict</code>, optional</dt>
<dd>Dictionary mapping elements to their pseudoelement names for each oxidation state
Format: {element: {ox_state_string: pseudoelement_name}}</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Dissociation reaction string, or None if generation fails</dd>
</dl></div>
</dd>
<dt id="aqequil.dissrxn_generator.get_lcm_list"><code class="name flex">
<span>def <span class="ident">get_lcm_list</span></span>(<span>numbers)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_lcm_list(numbers):
    &#34;&#34;&#34;Get the least common multiple of a list of numbers.&#34;&#34;&#34;
    if len(numbers) == 0:
        return 1
    result = numbers[0]
    for num in numbers[1:]:
        result = lcm(result, num)
    return result</code></pre>
</details>
<div class="desc"><p>Get the least common multiple of a list of numbers.</p></div>
</dd>
<dt id="aqequil.dissrxn_generator.get_simplest_basis"><code class="name flex">
<span>def <span class="ident">get_simplest_basis</span></span>(<span>basis_candidates, elem)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_simplest_basis(basis_candidates, elem):
    &#34;&#34;&#34;
    Get the simplest basis species for an element (fewest total atoms).

    Parameters
    ----------
    basis_candidates : list
        List of candidate basis species names
    elem : str
        Element to represent

    Returns
    -------
    str
        Name of simplest basis species, or None if none found
    &#34;&#34;&#34;
    min_complexity = float(&#39;inf&#39;)
    simplest = None

    for candidate in basis_candidates:
        try:
            mkp = chnosz.makeup(candidate)
            # Calculate complexity as sum of absolute values
            complexity = sum(abs(v) for v in mkp.values())

            # Prefer species with 1 atom of the element
            if elem in mkp and mkp[elem] == 1:
                complexity -= 0.5  # Bonus for having 1 atom

            if complexity &lt; min_complexity:
                min_complexity = complexity
                simplest = candidate

        except:
            continue

    return simplest</code></pre>
</details>
<div class="desc"><p>Get the simplest basis species for an element (fewest total atoms).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>basis_candidates</code></strong> :&ensp;<code>list</code></dt>
<dd>List of candidate basis species names</dd>
<dt><strong><code>elem</code></strong> :&ensp;<code>str</code></dt>
<dd>Element to represent</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>Name of simplest basis species, or None if none found</dd>
</dl></div>
</dd>
<dt id="aqequil.dissrxn_generator.lcm"><code class="name flex">
<span>def <span class="ident">lcm</span></span>(<span>a, b)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def lcm(a, b):
    &#34;&#34;&#34;Least common multiple.&#34;&#34;&#34;
    if a == 0 or b == 0:
        return 0
    return abs(a * b) // gcd(a, b)</code></pre>
</details>
<div class="desc"><p>Least common multiple.</p></div>
</dd>
<dt id="aqequil.dissrxn_generator.match_basis_comp"><code class="name flex">
<span>def <span class="ident">match_basis_comp</span></span>(<span>sp_elements, elem)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def match_basis_comp(sp_elements, elem):
    &#34;&#34;&#34;
    Check if a species contains only elem, H, O, and charge.

    Parameters
    ----------
    sp_elements : list
        List of elements in the species
    elem : str
        Element to check for

    Returns
    -------
    bool
        True if species matches basis composition requirements
    &#34;&#34;&#34;
    if elem in sp_elements:
        valid_elements = set([elem, &#39;H&#39;, &#39;O&#39;, &#39;Z&#39;])
        return all(e in valid_elements for e in sp_elements)
    return False</code></pre>
</details>
<div class="desc"><p>Check if a species contains only elem, H, O, and charge.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sp_elements</code></strong> :&ensp;<code>list</code></dt>
<dd>List of elements in the species</dd>
<dt><strong><code>elem</code></strong> :&ensp;<code>str</code></dt>
<dd>Element to check for</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if species matches basis composition requirements</dd>
</dl></div>
</dd>
<dt id="aqequil.dissrxn_generator.reduce_coefficients"><code class="name flex">
<span>def <span class="ident">reduce_coefficients</span></span>(<span>coeffs, tolerance=1e-06)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reduce_coefficients(coeffs, tolerance=1e-6):
    &#34;&#34;&#34;
    Reduce integer coefficients to their simplest form by dividing by their GCD.

    Parameters
    ----------
    coeffs : list
        List of integer coefficient values
    tolerance : float
        Tolerance for considering a coefficient as zero

    Returns
    -------
    list
        List of reduced integer coefficients
    &#34;&#34;&#34;
    # Filter out zero coefficients for GCD calculation
    non_zero_coeffs = [abs(int(round(c))) for c in coeffs if abs(c) &gt; tolerance]

    if not non_zero_coeffs:
        return coeffs

    # Calculate GCD of all non-zero coefficients
    result_gcd = non_zero_coeffs[0]
    for coeff in non_zero_coeffs[1:]:
        result_gcd = gcd(result_gcd, coeff)

    # If GCD is 1, coefficients are already reduced
    if result_gcd &lt;= 1:
        return coeffs

    # Divide all coefficients by GCD
    reduced_coeffs = [c / result_gcd for c in coeffs]

    return reduced_coeffs</code></pre>
</details>
<div class="desc"><p>Reduce integer coefficients to their simplest form by dividing by their GCD.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>coeffs</code></strong> :&ensp;<code>list</code></dt>
<dd>List of integer coefficient values</dd>
<dt><strong><code>tolerance</code></strong> :&ensp;<code>float</code></dt>
<dd>Tolerance for considering a coefficient as zero</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>list</code></dt>
<dd>List of reduced integer coefficients</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="aqequil" href="index.html">aqequil</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="aqequil.dissrxn_generator.coefficients_to_integers" href="#aqequil.dissrxn_generator.coefficients_to_integers">coefficients_to_integers</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.find_species_needing_dissrxns" href="#aqequil.dissrxn_generator.find_species_needing_dissrxns">find_species_needing_dissrxns</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.gcd" href="#aqequil.dissrxn_generator.gcd">gcd</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.generate_dissrxn" href="#aqequil.dissrxn_generator.generate_dissrxn">generate_dissrxn</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.get_lcm_list" href="#aqequil.dissrxn_generator.get_lcm_list">get_lcm_list</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.get_simplest_basis" href="#aqequil.dissrxn_generator.get_simplest_basis">get_simplest_basis</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.lcm" href="#aqequil.dissrxn_generator.lcm">lcm</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.match_basis_comp" href="#aqequil.dissrxn_generator.match_basis_comp">match_basis_comp</a></code></li>
<li><code><a title="aqequil.dissrxn_generator.reduce_coefficients" href="#aqequil.dissrxn_generator.reduce_coefficients">reduce_coefficients</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
